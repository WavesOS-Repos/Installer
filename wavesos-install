#!/bin/bash

# WavesOS Installation Script
# A custom Arch Linux distribution installer
# Version: 3.0 - Critical Bootloader Fixes for Boot Device Issues

set -euo pipefail # Exit on error, undefined vars, pipe failures

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Logging functions
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
}

error() {
    echo -e "${RED}[ERROR] $1${NC}" >&2
    exit 1
}

warning() {
    echo -e "${YELLOW}[WARNING] $1${NC}"
}

info() {
    echo -e "${BLUE}[INFO] $1${NC}"
}

success() {
    echo -e "${CYAN}[SUCCESS] $1${NC}"
}

# Progress indicator
show_progress() {
    local current=$1
    local total=$2
    local desc="$3"
    local percent=$((current * 100 / total))
    local filled=$((percent / 2))
    local empty=$((50 - filled))
    
    printf "\r${PURPLE}[%3d%%]${NC} [" "$percent"
    printf "%*s" "$filled" | tr ' ' '='
    printf "%*s" "$empty" | tr ' ' '-'
    printf "] %s" "$desc"
    
    if [ "$current" -eq "$total" ]; then
        echo
    fi
}

# Banner
show_banner() {
    clear
    echo -e "${CYAN}"
       echo "

██╗    ██╗ █████╗ ██╗   ██╗███████╗███████╗ ██████╗ ███████╗    ██╗███╗   ██╗███████╗████████╗ █████╗ ██╗     ██╗     ███████╗██████╗ 
██║    ██║██╔══██╗██║   ██║██╔════╝██╔════╝██╔═══██╗██╔════╝    ██║████╗  ██║██╔════╝╚══██╔══╝██╔══██╗██║     ██║     ██╔════╝██╔══██╗
██║ █╗ ██║███████║██║   ██║█████╗  ███████╗██║   ██║███████╗    ██║██╔██╗ ██║███████╗   ██║   ███████║██║     ██║     █████╗  ██████╔╝
██║███╗██║██╔══██║╚██╗ ██╔╝██╔══╝  ╚════██║██║   ██║╚════██║    ██║██║╚██╗██║╚════██║   ██║   ██╔══██║██║     ██║     ██╔══╝  ██╔══██╗
╚███╔███╔╝██║  ██║ ╚████╔╝ ███████╗███████║╚██████╔╝███████║    ██║██║ ╚████║███████║   ██║   ██║  ██║███████╗███████╗███████╗██║  ██║
 ╚══╝╚══╝ ╚═╝  ╚═╝  ╚═══╝  ╚══════╝╚══════╝ ╚═════╝ ╚══════╝    ╚═╝╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝╚═╝  ╚═╝
                                                                                                                                      

"
    echo -e "${NC}"
    echo
}

# Check if run as root
check_root() {
    if [ "$EUID" -ne 0 ]; then
        error "Please run as root with sudo"
    fi
}

# Check if running in live environment
check_live_env() {
    if ! grep -q "archiso" /proc/cmdline 2>/dev/null; then
        warning "This script is designed to run from Arch Linux live environment"
        read -p "Continue anyway? (y/N): " continue_anyway
        [[ "${continue_anyway,,}" != "y" ]] && error "Installation cancelled"
    fi
}

# Ensure required tools are available
check_tools() {
    local tools=(parted mkfs.fat mkfs.ext4 pacstrap arch-chroot genfstab grub-install reflector lsblk blkid rsync git efibootmgr)
    
    log "Checking required tools..."
    for cmd in "${tools[@]}"; do
        if ! command -v "$cmd" &>/dev/null; then
            error "$cmd is required but not installed"
        fi
    done
    success "All required tools are available"
}

# Check network connectivity
check_network() {
    log "Checking network connectivity..."
    if ! ping -c 3 -W 5 archlinux.org &>/dev/null; then
        error "No internet connection detected. Please connect to a network and try again."
    fi
    success "Network connectivity confirmed"
}

# Update system clock
update_clock() {
    log "Updating system clock..."
    timedatectl set-ntp true
    sleep 2
    success "System clock updated"
}

# Enhanced disk detection with USB exclusion
detect_disks() {
    log "Detecting available disks (excluding USB drives)..."
    
    # Get all block devices that are disks
    mapfile -t ALL_DISKS < <(lsblk -d -n -o NAME,SIZE,TYPE,TRAN,HOTPLUG | grep disk)
    
    # Filter out USB drives and hot-pluggable devices
    DISK_LIST=()
    for disk_info in "${ALL_DISKS[@]}"; do
        read -r name size type tran hotplug <<<"$disk_info"
        
        # Skip if it's a USB device or hot-pluggable
        if [[ "$tran" == "usb" ]] || [[ "$hotplug" == "1" ]]; then
            warning "Excluding USB/hotplug device: /dev/$name"
            continue
        fi
        
        # Additional check: exclude if mounted under /run/archiso
        if mount | grep -q "/dev/$name.*archiso"; then
            warning "Excluding archiso device: /dev/$name"
            continue
        fi
        
        # Additional check: exclude if it's the current root device
        root_device=$(findmnt -n -o SOURCE /)
        if [[ "$root_device" == *"$name"* ]]; then
            warning "Excluding current root device: /dev/$name"
            continue
        fi
        
        DISK_LIST+=("$disk_info")
    done
    
    if [ ${#DISK_LIST[@]} -eq 0 ]; then
        error "No suitable disks found! All detected disks appear to be USB or system devices."
    fi
    
    success "Found ${#DISK_LIST[@]} suitable disk(s) for installation"
}

# Display hardware specs
show_hardware() {
    log "Hardware Specifications:"
    info "CPU: $(lscpu | grep "Model name" | awk -F: '{print $2}' | xargs)"
    info "RAM: $(free -h | awk '/^Mem:/ {print $2}')"
    info "GPU: $(lspci | grep -i vga | cut -d: -f3 | xargs || echo 'Not detected')"
    echo
    info "Available storage devices:"
    printf "%-10s %-10s %-10s %-10s %s\n" "DEVICE" "SIZE" "TYPE" "TRANSPORT" "MODEL"
    printf "%-10s %-10s %-10s %-10s %s\n" "------" "----" "----" "---------" "-----"
    
    for disk_info in "${DISK_LIST[@]}"; do
        read -r name size type tran hotplug <<<"$disk_info"
        model=$(lsblk -d -n -o MODEL "/dev/$name" 2>/dev/null || echo "Unknown")
        printf "%-10s %-10s %-10s %-10s %s\n" "/dev/$name" "$size" "$type" "$tran" "$model"
    done
    echo
    read -p "Press Enter to continue..."
}

# Disk selection with enhanced validation
select_disks() {
    # Show disk options
    echo "Available disks for installation:"
    for i in "${!DISK_LIST[@]}"; do
        read -r name size type tran hotplug <<<"${DISK_LIST[$i]}"
        model=$(lsblk -d -n -o MODEL "/dev/$name" 2>/dev/null || echo "Unknown")
        echo "$i) /dev/$name - $size ($type via $tran) - $model"
    done
    echo
    
    # System disk selection
    while true; do
        read -p "Select system disk number (for root installation): " SYS_DISK_IDX
        if [[ "$SYS_DISK_IDX" =~ ^[0-9]+$ ]] && [ "$SYS_DISK_IDX" -lt ${#DISK_LIST[@]} ]; then
            break
        fi
        error "Invalid system disk selection. Please enter a number between 0 and $((${#DISK_LIST[@]} - 1))"
    done
    
    SYS_DISK="/dev/$(echo "${DISK_LIST[$SYS_DISK_IDX]}" | awk '{print $1}')"
    log "Selected system disk: $SYS_DISK"
    
    # Verify disk is not mounted
    if mount | grep -q "$SYS_DISK"; then
        error "Selected disk $SYS_DISK appears to be in use. Please unmount it first."
    fi
    
    # Remove selected disk from list
    unset 'DISK_LIST[$SYS_DISK_IDX]'
    DISK_LIST=("${DISK_LIST[@]}") # Reindex array
    
    # Storage disk selection (optional)
    STORE_DISK=""
    if [ ${#DISK_LIST[@]} -gt 0 ]; then
        echo
        echo "Remaining disks for additional storage:"
        for i in "${!DISK_LIST[@]}"; do
            read -r name size type tran hotplug <<<"${DISK_LIST[$i]}"
            model=$(lsblk -d -n -o MODEL "/dev/$name" 2>/dev/null || echo "Unknown")
            echo "$i) /dev/$name - $size ($type via $tran) - $model"
        done
        read -p "Select storage disk number (or press Enter for none): " STORE_DISK_IDX
        if [[ "$STORE_DISK_IDX" =~ ^[0-9]+$ ]] && [ "$STORE_DISK_IDX" -lt ${#DISK_LIST[@]} ]; then
            STORE_DISK="/dev/$(echo "${DISK_LIST[$STORE_DISK_IDX]}" | awk '{print $1}')"
            log "Selected storage disk: $STORE_DISK"
        fi
    fi
}

# Enhanced boot mode detection
detect_boot_mode() {
    if [ -d /sys/firmware/efi ]; then
        BOOT_MODE="uefi"
        PTABLE="gpt"
        log "UEFI system detected, using GPT partition table"
        
        # Verify EFI variables are accessible
        if ! efivar -l &>/dev/null; then
            warning "EFI variables not accessible, but UEFI detected"
        fi
    else
        BOOT_MODE="bios"
        PTABLE="msdos"
        log "BIOS system detected, using MBR partition table"
    fi
}

# Partition configuration
configure_partitions() {
    # Get disk size for validation
    TOTAL_SIZE_BYTES=$(blockdev --getsize64 "$SYS_DISK")
    TOTAL_SIZE_GB=$((TOTAL_SIZE_BYTES / 1024 / 1024 / 1024))
    log "Total disk size: ${TOTAL_SIZE_GB}GB"
    
    # Partition size configuration
    if [ "$BOOT_MODE" = "uefi" ]; then
        while true; do
            read -p "Enter EFI partition size in MB (default: 512): " EFI_SIZE
            EFI_SIZE=${EFI_SIZE:-512}
            if [[ "$EFI_SIZE" =~ ^[0-9]+$ ]] && [ "$EFI_SIZE" -ge 256 ] && [ "$EFI_SIZE" -le 2048 ]; then
                break
            fi
            warning "EFI partition size must be between 256MB and 2048MB"
        done
    else
        EFI_SIZE=0
    fi
    
    # Swap configuration
    RAM_SIZE_GB=$(free -g | awk '/^Mem:/ {print $2}')
    RECOMMENDED_SWAP=$((RAM_SIZE_GB <= 8 ? RAM_SIZE_GB * 2 : RAM_SIZE_GB))
    
    echo
    info "RAM detected: ${RAM_SIZE_GB}GB"
    info "Recommended swap: ${RECOMMENDED_SWAP}GB"
    read -p "Enter swap partition size in GB (recommended: ${RECOMMENDED_SWAP}GB, 0 for none): " SWAP_SIZE
    SWAP_SIZE=${SWAP_SIZE:-$RECOMMENDED_SWAP}
    
    if ! [[ "$SWAP_SIZE" =~ ^[0-9]+$ ]]; then
        warning "Invalid swap size, using recommended: ${RECOMMENDED_SWAP}GB"
        SWAP_SIZE=$RECOMMENDED_SWAP
    fi
    
    # Root partition size
    USED_SPACE=$((EFI_SIZE / 1024 + SWAP_SIZE))
    AVAILABLE_SPACE=$((TOTAL_SIZE_GB - USED_SPACE))
    
    if [ "$AVAILABLE_SPACE" -le 0 ]; then
        error "Not enough disk space. Need at least $((USED_SPACE + 20))GB"
    fi
    
    read -p "Enter root partition size in GB (0 for remaining ${AVAILABLE_SPACE}GB): " ROOT_SIZE
    ROOT_SIZE=${ROOT_SIZE:-0}
    
    if [ "$ROOT_SIZE" -eq 0 ]; then
        ROOT_SIZE=$AVAILABLE_SPACE
    elif [ "$ROOT_SIZE" -gt "$AVAILABLE_SPACE" ]; then
        warning "Root size too large, using available space: ${AVAILABLE_SPACE}GB"
        ROOT_SIZE=$AVAILABLE_SPACE
    fi
    
    if [ "$ROOT_SIZE" -lt 20 ]; then
        error "Root partition must be at least 20GB for WavesOS"
    fi
}

# Confirm partitioning
confirm_partitioning() {
    echo
    echo -e "${YELLOW}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${YELLOW}║                    PARTITIONING SUMMARY                   ║${NC}"
    echo -e "${YELLOW}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    info "Target disk: $SYS_DISK (${TOTAL_SIZE_GB}GB)"
    [ "$BOOT_MODE" = "uefi" ] && info "EFI partition: ${EFI_SIZE}MB"
    [ "$SWAP_SIZE" -gt 0 ] && info "Swap partition: ${SWAP_SIZE}GB"
    info "Root partition: ${ROOT_SIZE}GB (ext4)"
    [ -n "$STORE_DISK" ] && info "Storage disk: $STORE_DISK (full disk, ext4)"
    echo
    warning "⚠️  THIS WILL PERMANENTLY DESTROY ALL DATA ON THE SELECTED DISK(S)! ⚠️"
    echo
    
    read -p "Type 'YES' to confirm and proceed with installation: " CONFIRM
    if [ "$CONFIRM" != "YES" ]; then
        error "Installation cancelled by user"
    fi
}

# Enhanced partitioning with better error handling
create_partitions() {
    log "Creating partitions on $SYS_DISK..."
    
    # Unmount any mounted partitions from target disk
    umount "$SYS_DISK"* 2>/dev/null || true
    
    # Wipe filesystem signatures
    wipefs -af "$SYS_DISK" || error "Failed to wipe filesystem signatures"
    
    # Create partition table
    parted "$SYS_DISK" --script mklabel "$PTABLE" || error "Failed to create partition table"
    
    PART_NUM=1
    if [ "$BOOT_MODE" = "uefi" ]; then
        # Create EFI partition
        parted "$SYS_DISK" --script mkpart primary fat32 1MiB ${EFI_SIZE}MiB || error "Failed to create EFI partition"
        parted "$SYS_DISK" --script set $PART_NUM esp on || error "Failed to set ESP flag"
        EFI_PART="${SYS_DISK}${PART_NUM}"
        PART_NUM=$((PART_NUM + 1))
        START_POS="${EFI_SIZE}MiB"
    else
        # Create BIOS boot partition
        parted "$SYS_DISK" --script mkpart primary 1MiB 2MiB || error "Failed to create BIOS boot partition"
        parted "$SYS_DISK" --script set $PART_NUM bios_grub on || error "Failed to set bios_grub flag"
        BIOS_BOOT_PART="${SYS_DISK}${PART_NUM}"
        PART_NUM=$((PART_NUM + 1))
        START_POS="2MiB"
    fi
    
    # Create swap partition
    if [ "$SWAP_SIZE" -gt 0 ]; then
        END_POS="$((${START_POS%MiB} + SWAP_SIZE * 1024))MiB"
        parted "$SYS_DISK" --script mkpart primary linux-swap "$START_POS" "$END_POS" || error "Failed to create swap partition"
        SWAP_PART="${SYS_DISK}${PART_NUM}"
        PART_NUM=$((PART_NUM + 1))
        START_POS="$END_POS"
    fi
    
    # Create root partition
    parted "$SYS_DISK" --script mkpart primary ext4 "$START_POS" 100% || error "Failed to create root partition"
    ROOT_PART="${SYS_DISK}${PART_NUM}"
    
    # Handle NVMe drives partition naming
    if [[ "$SYS_DISK" == *"nvme"* ]]; then
        if [ "$BOOT_MODE" = "uefi" ]; then
            EFI_PART="${SYS_DISK}p1"
            if [ "$SWAP_SIZE" -gt 0 ]; then
                SWAP_PART="${SYS_DISK}p2"
                ROOT_PART="${SYS_DISK}p3"
            else
                ROOT_PART="${SYS_DISK}p2"
            fi
        else
            BIOS_BOOT_PART="${SYS_DISK}p1"
            if [ "$SWAP_SIZE" -gt 0 ]; then
                SWAP_PART="${SYS_DISK}p2"
                ROOT_PART="${SYS_DISK}p3"
            else
                ROOT_PART="${SYS_DISK}p2"
            fi
        fi
    fi
    
    # Handle storage disk
    if [ -n "$STORE_DISK" ]; then
        log "Partitioning storage disk $STORE_DISK..."
        umount "$STORE_DISK"* 2>/dev/null || true
        wipefs -af "$STORE_DISK" || error "Failed to wipe storage disk"
        parted "$STORE_DISK" --script mklabel "$PTABLE" || error "Failed to create storage partition table"
        parted "$STORE_DISK" --script mkpart primary ext4 1MiB 100% || error "Failed to create storage partition"
        
        if [[ "$STORE_DISK" == *"nvme"* ]]; then
            STORAGE_PART="${STORE_DISK}p1"
        else
            STORAGE_PART="${STORE_DISK}1"
        fi
    fi
    
    # Wait for partitions to be created and refresh
    sleep 3
    partprobe "$SYS_DISK" || error "Failed to refresh partition table"
    [ -n "$STORE_DISK" ] && partprobe "$STORE_DISK"
    
    # Verify partitions exist
    for i in {1..10}; do
        if [ -b "$ROOT_PART" ]; then
            break
        fi
        sleep 1
    done
    
    [ ! -b "$ROOT_PART" ] && error "Root partition $ROOT_PART was not created"
    success "Partitions created successfully"
}

# Format partitions with enhanced error handling
format_partitions() {
    log "Formatting partitions..."
    
    if [ "$BOOT_MODE" = "uefi" ]; then
        show_progress 1 4 "Formatting EFI partition..."
        mkfs.fat -F32 -n "EFI" "$EFI_PART" || error "Failed to format EFI partition"
    fi
    
    if [ "$SWAP_SIZE" -gt 0 ]; then
        show_progress 2 4 "Formatting swap partition..."
        mkswap -L "SWAP" "$SWAP_PART" || error "Failed to format swap partition"
    fi
    
    show_progress 3 4 "Formatting root partition..."
    mkfs.ext4 -F -L "ROOT" "$ROOT_PART" || error "Failed to format root partition"
    
    if [ -n "$STORE_DISK" ]; then
        show_progress 4 4 "Formatting storage partition..."
        mkfs.ext4 -F -L "STORAGE" "$STORAGE_PART" || error "Failed to format storage partition"
    fi
    
    show_progress 4 4 "Partition formatting complete"
    success "All partitions formatted successfully"
}

# Mount partitions with verification
mount_partitions() {
    log "Mounting partitions..."
    
    # Mount root
    mount "$ROOT_PART" /mnt || error "Failed to mount root partition"
    
    # Create and mount boot/EFI
    if [ "$BOOT_MODE" = "uefi" ]; then
        mkdir -p /mnt/boot
        mount "$EFI_PART" /mnt/boot || error "Failed to mount EFI partition"
    fi
    
    # Enable swap
    if [ "$SWAP_SIZE" -gt 0 ]; then
        swapon "$SWAP_PART" || error "Failed to enable swap"
    fi
    
    # Mount storage
    if [ -n "$STORE_DISK" ]; then
        mkdir -p /mnt/home/storage
        mount "$STORAGE_PART" /mnt/home/storage || error "Failed to mount storage partition"
    fi
    
    success "All partitions mounted successfully"
}

# Update mirrorlist
update_mirrorlist() {
    log "Updating mirrorlist for optimal download speeds..."
    echo "Select your country for optimal mirrors:"
    echo "1) United States    2) United Kingdom   3) Germany"
    echo "4) France          5) Canada           6) Australia"
    echo "7) India           8) Japan            9) Custom"
    
    read -p "Select country (1-9): " COUNTRY_CHOICE
    case $COUNTRY_CHOICE in
        1) COUNTRY="US" ;;
        2) COUNTRY="GB" ;;
        3) COUNTRY="DE" ;;
        4) COUNTRY="FR" ;;
        5) COUNTRY="CA" ;;
        6) COUNTRY="AU" ;;
        7) COUNTRY="IN" ;;
        8) COUNTRY="JP" ;;
        9) read -p "Enter country code (e.g., SE for Sweden): " COUNTRY ;;
        *) COUNTRY="US" ;;
    esac
    
    info "Updating mirrors for country: $COUNTRY"
    reflector --country "$COUNTRY" --age 12 --protocol https --sort rate --save /etc/pacman.d/mirrorlist || {
        warning "Failed to update mirrorlist, using default"
    }
    success "Mirrorlist updated"
}

# Install base system
install_base_system() {
    log "Installing base system packages..."
    
    local base_packages=(
        base base-devel linux linux-firmware linux-headers
        networkmanager dhcpcd iwd wireless_tools wpa_supplicant
        sudo nano vim git curl wget rsync
        bash-completion man-db man-pages
        reflector pacman-contrib
    )
    
    show_progress 1 3 "Installing base system..."
    if ! pacstrap /mnt "${base_packages[@]}"; then
        error "Failed to install base system packages"
    fi
    
    success "Base system installed successfully"
}

# Install bootloader packages
install_bootloader_packages() {
    log "Installing bootloader packages..."
    
    if [ "$BOOT_MODE" = "uefi" ]; then
        show_progress 2 3 "Installing UEFI bootloader..."
        if ! pacstrap /mnt grub efibootmgr dosfstools; then
            error "Failed to install UEFI bootloader packages"
        fi
    else
        show_progress 2 3 "Installing BIOS bootloader..."
        if ! pacstrap /mnt grub; then
            error "Failed to install BIOS bootloader packages"
        fi
    fi
    
    success "Bootloader packages installed"
}

# Install graphics drivers
install_graphics_drivers() {
    log "Graphics driver selection:"
    echo "1) Intel (open-source)"
    echo "2) AMD (open-source)" 
    echo "3) NVIDIA (proprietary)"
    echo "4) NVIDIA (open-source nouveau)"
    echo "5) Generic/VM (VESA)"
    
    read -p "Select graphics driver (1-5): " GPU_CHOICE
    
    case $GPU_CHOICE in
        1) gpu_packages=(xf86-video-intel intel-media-driver vulkan-intel) ;;
        2) gpu_packages=(xf86-video-amdgpu mesa vulkan-radeon libva-mesa-driver) ;;
        3) gpu_packages=(nvidia nvidia-utils nvidia-settings) ;;
        4) gpu_packages=(xf86-video-nouveau mesa) ;;
        5) gpu_packages=(xf86-video-vesa mesa) ;;
        *) gpu_packages=(xf86-video-vesa mesa) ;;
    esac
    
    show_progress 3 3 "Installing graphics drivers..."
    if ! pacstrap /mnt "${gpu_packages[@]}"; then
        warning "Some graphics packages failed to install"
    fi
    
    success "Graphics drivers installed"
}

# Install WavesOS desktop environment
install_desktop_environment() {
    log "Installing WavesOS desktop environment..."
    
    local de_packages=(
        # Hyprland and Wayland
        hyprland waybar wofi dunst
        xorg-xwayland qt5-wayland qt6-wayland
        
        # Audio
        pipewire pipewire-alsa pipewire-pulse pipewire-jack wireplumber
        
        # File manager and utilities
        thunar thunar-volman gvfs tumbler
        
        # Applications
        firefox alacritty kitty
        
        # Display manager
        sddm
        
        # Fonts
        ttf-dejavu ttf-liberation noto-fonts noto-fonts-emoji
        ttf-fira-code ttf-opensans
        
        # System utilities
        polkit-gnome
        brightnessctl playerctl
        grim slurp wl-clipboard
        network-manager-applet
        pavucontrol
        
        # Additional Hyprland ecosystem
        hypridle hyprlock hyprpaper
        xdg-desktop-portal-hyprland
        
        # Theme and customization
        gtk3 gtk4
        qt5ct qt6ct
        
        # System monitoring and utilities
        htop neofetch
        zip unzip p7zip
        
        # Development tools
        code python python-pip nodejs npm
    )
    
    info "Installing ${#de_packages[@]} desktop environment packages..."
    
    for i in "${!de_packages[@]}"; do
        local current=$((i + 1))
        show_progress "$current" "${#de_packages[@]}" "Installing ${de_packages[$i]}..."
        
        if ! pacstrap /mnt "${de_packages[$i]}" 2>/dev/null; then
            warning "Failed to install ${de_packages[$i]}, continuing..."
        fi
    done
    
    success "Desktop environment installation completed"
}

# Install custom packages
install_custom_packages() {
    if [ -f /root/packages.x86_64 ]; then
        log "Installing custom packages from /root/packages.x86_64..."
        mapfile -t custom_packages < <(grep -v '^#' /root/packages.x86_64 | grep -v '^\s*$')
        
        if [ ${#custom_packages[@]} -gt 0 ]; then
            for pkg in "${custom_packages[@]}"; do
                info "Installing custom package: $pkg"
                if ! pacstrap /mnt "$pkg" 2>/dev/null; then
                    warning "Failed to install custom package: $pkg"
                fi
            done
            success "Custom packages installation completed"
        else
            warning "No valid packages found in /root/packages.x86_64"
        fi
    else
        info "No custom packages file found, skipping"
    fi
}

# Copy custom repository
copy_custom_repo() {
    if [ -d /custom-repo ] && [ -f /custom-repo/custom-repo.db ]; then
        log "Copying custom repository to installed system..."
        mkdir -p /mnt/custom-repo
        if cp -r /custom-repo/* /mnt/custom-repo/; then
            success "Custom repository copied successfully"
        else
            warning "Failed to copy some custom repository files"
        fi
    else
        info "No custom repository found, skipping"
    fi
}

# Generate fstab
generate_fstab() {
    log "Generating filesystem table (fstab)..."
    if genfstab -U /mnt >> /mnt/etc/fstab; then
        success "fstab generated successfully"
    else
        error "Failed to generate fstab"
    fi
}

# Configure system settings
configure_system() {
    log "Configuring system settings..."
    
    # Locale configuration
    echo "Select system locale:"
    echo "1) en_US.UTF-8 (English - United States)"
    echo "2) en_GB.UTF-8 (English - United Kingdom)"
    echo "3) de_DE.UTF-8 (German - Germany)"
    echo "4) fr_FR.UTF-8 (French - France)"
    echo "5) es_ES.UTF-8 (Spanish - Spain)"
    echo "6) Custom locale"
    
    read -p "Select locale (1-6): " LOCALE_CHOICE
    case $LOCALE_CHOICE in
        1) LOCALE="en_US.UTF-8 UTF-8" ;;
        2) LOCALE="en_GB.UTF-8 UTF-8" ;;
        3) LOCALE="de_DE.UTF-8 UTF-8" ;;
        4) LOCALE="fr_FR.UTF-8 UTF-8" ;;
        5) LOCALE="es_ES.UTF-8 UTF-8" ;;
        6) read -p "Enter locale (e.g., ja_JP.UTF-8): " LOCALE ;;
        *) LOCALE="en_US.UTF-8 UTF-8" ;;
    esac
    
    # Timezone configuration
    echo
    echo "Select timezone:"
    echo "1) America/New_York    2) America/Los_Angeles"
    echo "3) Europe/London       4) Europe/Berlin"
    echo "5) Asia/Tokyo          6) Asia/Kolkata"
    echo "7) Australia/Sydney    8) Custom timezone"
    
    read -p "Select timezone (1-8): " TZ_CHOICE
    case $TZ_CHOICE in
        1) TIMEZONE="America/New_York" ;;
        2) TIMEZONE="America/Los_Angeles" ;;
        3) TIMEZONE="Europe/London" ;;
        4) TIMEZONE="Europe/Berlin" ;;
        5) TIMEZONE="Asia/Tokyo" ;;
        6) TIMEZONE="Asia/Kolkata" ;;
        7) TIMEZONE="Australia/Sydney" ;;
        8) read -p "Enter timezone (e.g., Europe/Stockholm): " TIMEZONE ;;
        *) TIMEZONE="UTC" ;;
    esac
    
    # Hostname
    echo
    read -p "Enter hostname for this system (default: wavesos): " HOSTNAME
    HOSTNAME=${HOSTNAME:-wavesos}
    
    # User configuration
    echo
    read -p "Enter username for the main user account: " USERNAME
    while [[ -z "$USERNAME" || "$USERNAME" = "root" ]]; do
        warning "Invalid username. Please enter a valid username (not root):"
        read -p "Username: " USERNAME
    done
    
    success "System configuration collected"
}

# Apply system configuration in chroot
apply_chroot_config() {
    log "Applying system configuration..."
    
    # Create chroot script
    cat > /mnt/setup_system.sh << 'EOF'
#!/bin/bash
set -euo pipefail

# Configure locale
echo "$1" > /etc/locale.gen
locale-gen
echo "LANG=${1%% *}" > /etc/locale.conf

# Configure timezone
ln -sf "/usr/share/zoneinfo/$2" /etc/localtime
hwclock --systohc

# Configure hostname
echo "$3" > /etc/hostname

# Configure hosts file
cat > /etc/hosts << HOSTS_EOF
127.0.0.1   localhost
::1         localhost
127.0.1.1   $3.localdomain $3
HOSTS_EOF

# Enable essential services
systemctl enable NetworkManager
systemctl enable sddm
systemctl enable bluetooth

# Configure pacman
sed -i 's/#Color/Color/' /etc/pacman.conf
sed -i 's/#ParallelDownloads = 5/ParallelDownloads = 5/' /etc/pacman.conf

# Create user
useradd -m -G wheel,audio,video,optical,storage -s /bin/bash "$4"
echo "Set password for user $4:"
passwd "$4"

echo "Set password for root:"
passwd

# Configure sudo
echo '%wheel ALL=(ALL:ALL) ALL' > /etc/sudoers.d/wheel

# Configure mkinitcpio
mkinitcpio -P

echo "System configuration completed successfully"
EOF

    chmod +x /mnt/setup_system.sh
    
    # Execute in chroot
    if arch-chroot /mnt /setup_system.sh "$LOCALE" "$TIMEZONE" "$HOSTNAME" "$USERNAME"; then
        success "System configuration applied successfully"
    else
        error "Failed to apply system configuration"
    fi
    
    # Cleanup
    rm /mnt/setup_system.sh
}

# CRITICAL BOOTLOADER INSTALLATION - Fixed for "Boot device not found" issue
install_bootloader() {
    log "Installing and configuring bootloader (Critical Boot Fix)..."
    
    # Create CORRECTED bootloader installation script
    cat > /mnt/install_bootloader.sh << EOF
#!/bin/bash
set -euo pipefail

BOOT_MODE="$BOOT_MODE"
SYS_DISK="$SYS_DISK"

echo "=== CRITICAL BOOTLOADER INSTALLATION ==="
echo "Installing bootloader for \$BOOT_MODE mode on \$SYS_DISK"

# CRITICAL FIX 1: Ensure EFI variables are properly mounted
if [ "\$BOOT_MODE" = "uefi" ]; then
    echo "Mounting EFI variables..."
    modprobe efivarfs 2>/dev/null || true
    mount -t efivarfs efivarfs /sys/firmware/efi/efivars 2>/dev/null || true
fi

# CRITICAL FIX 2: Configure GRUB with proper WavesOS branding
echo "Configuring GRUB defaults..."
sed -i 's/GRUB_DISTRIBUTOR="Arch"/GRUB_DISTRIBUTOR="WavesOS"/' /etc/default/grub
sed -i 's/#GRUB_DISABLE_OS_PROBER=false/GRUB_DISABLE_OS_PROBER=false/' /etc/default/grub

# Add timeout to prevent hanging
echo 'GRUB_TIMEOUT=5' >> /etc/default/grub

if [ "\$BOOT_MODE" = "uefi" ]; then
    echo "Installing GRUB for UEFI..."
    
    # CRITICAL FIX 3: Use --removable flag for better compatibility
    if grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=WavesOS --recheck --removable; then
        echo "UEFI GRUB installation successful"
    else
        echo "Primary UEFI installation failed, trying fallback method..."
        # Fallback: Install to default EFI location
        grub-install --target=x86_64-efi --efi-directory=/boot --removable || {
            echo "ERROR: Both UEFI installation methods failed"
            exit 1
        }
    fi
    
    # CRITICAL FIX 4: Create fallback EFI bootloader
    mkdir -p /boot/EFI/BOOT
    if [ -f /boot/EFI/WavesOS/grubx64.efi ]; then
        cp /boot/EFI/WavesOS/grubx64.efi /boot/EFI/BOOT/BOOTX64.EFI
        echo "Created fallback EFI bootloader"
    fi
    
else
    echo "Installing GRUB for BIOS..."
    
    # CRITICAL FIX 5: Ensure we're installing to the correct disk
    if grub-install --target=i386-pc --recheck "\$SYS_DISK"; then
        echo "BIOS GRUB installation successful"
    else
        echo "ERROR: Failed to install GRUB to \$SYS_DISK"
        exit 1
    fi
fi

# CRITICAL FIX 6: Generate GRUB config with error checking
echo "Generating GRUB configuration..."
if grub-mkconfig -o /boot/grub/grub.cfg; then
    echo "GRUB configuration generated successfully"
else
    echo "ERROR: Failed to generate GRUB configuration"
    exit 1
fi

# CRITICAL FIX 7: Verify installation thoroughly
echo "=== BOOTLOADER VERIFICATION ==="
if [ "\$BOOT_MODE" = "uefi" ]; then
    # Check for GRUB EFI files
    if [ -f /boot/EFI/WavesOS/grubx64.efi ] || [ -f /boot/EFI/BOOT/BOOTX64.EFI ]; then
        echo "✓ UEFI bootloader files verified"
    else
        echo "✗ ERROR: UEFI bootloader files missing"
        exit 1
    fi
    
    # Check EFI boot entries
    if command -v efibootmgr >/dev/null 2>&1; then
        efibootmgr -v
        if efibootmgr | grep -i "wavesos\|removable"; then
            echo "✓ EFI boot entry found"
        else
            echo "⚠ Warning: No specific WavesOS EFI entry, but removable entry should work"
        fi
    fi
else
    # Check BIOS installation
    if dd if="\$SYS_DISK" bs=512 count=1 2>/dev/null | strings | grep -q GRUB; then
        echo "✓ BIOS bootloader verified in MBR"
    else
        echo "✗ ERROR: BIOS bootloader not found in MBR"
        exit 1
    fi
fi

# Check GRUB configuration
if [ -f /boot/grub/grub.cfg ] && grep -q "WavesOS" /boot/grub/grub.cfg; then
    echo "✓ GRUB configuration verified"
else
    echo "✗ ERROR: GRUB configuration invalid"
    exit 1
fi

echo "=== BOOTLOADER INSTALLATION COMPLETED SUCCESSFULLY ==="
EOF

    chmod +x /mnt/install_bootloader.sh
    
    # Execute bootloader installation in chroot with enhanced error handling
    log "Executing bootloader installation in chroot..."
    if arch-chroot /mnt /install_bootloader.sh; then
        success "CRITICAL BOOTLOADER INSTALLATION SUCCESSFUL"
        
        # Additional host-level verification
        if [ "$BOOT_MODE" = "uefi" ]; then
            if [ -f "/mnt/boot/EFI/BOOT/BOOTX64.EFI" ] || [ -f "/mnt/boot/EFI/WavesOS/grubx64.efi" ]; then
                success "✓ Host verification: EFI bootloader files confirmed"
            else
                warning "⚠ Host verification: EFI files not found from host"
            fi
        fi
        
    else
        error "CRITICAL BOOTLOADER INSTALLATION FAILED - This will cause boot failure"
    fi
    
    # Cleanup
    rm /mnt/install_bootloader.sh
}

# Install and configure Hyprland configs
install_wavesos_customizations() {
    log "Installing WavesOS customizations..."

    # Verify /mnt is mounted
    if ! mountpoint -q /mnt; then
        error "Root partition /mnt is not mounted"
    fi

    show_progress 1 5 "Copying Hyprland configurations..."
    # Copy Hyprland configs to chroot
    if [ -d /root/Hyprland-configs ]; then
        cp -r /root/Hyprland-configs /mnt || error "Failed to copy Hyprland-configs to /mnt/tmp/Hyprland-configs"
    else
        error "Hyprland-configs directory not found at /root/Hyprland-configs"
    fi

    # Copy Hyprland configs to chroot
    if [ -d /root/WavesHyprland ]; then
        cp -r /root/WavesHyprland /mnt || error "Failed to copy WavesHyprland to /mnt/WavesHyprland"
    else
        error "WavesHyprland directory not found at /root/WavesHyprland"
    fi

    if [ -d /root/WavesHyprland-V2 ]; then
        cp -r /root/WavesHyprland-V2 /mnt || error "Failed to copy WavesHyprland to /mnt/WavesHyprland"
    else
        error "WavesHyprland directory not found at /root/WavesHyprland"
    fi


  
    show_progress 3 5 "Copying sleep.conf..."
    # Copy sleep.conf to target system
    if [ -f /etc/systemd/sleep.conf ]; then
        cp /etc/systemd/sleep.conf /mnt/etc/systemd/sleep.conf || error "Failed to copy sleep.conf to /mnt/etc/systemd/sleep.conf"
    else
        warning "No sleep.conf found at /etc/systemd/sleep.conf; skipping"
    fi

    show_progress 4 5 "Setting up configurations..."
    # Set permissions and run install.sh in chroot
  arch-chroot /mnt bash -c "
        if [ -f /Hyprland-configs/install.sh ]; then
            chmod +x /Hyprland-configs/install.sh || { echo 'Failed to make Hyprland install.sh executable' >&2; exit 1; }
           chown -R $USERNAME:$USERNAME Hyprland-configs
           chmod +x /Hyprland-configs/dnf-scripts/*.sh
           chmod +x /Hyprland-configs/zypper-scripts/*.sh
           chmod +x /Hyprland-configs/common/*.sh
           chmod +x /Hyprland-configs/pacman-scripts/*.sh
           chmod +x /Hyprland-configs/start.sh
            su - \"$USERNAME\" -c 'cd /Hyprland-configs 
            ./install.sh' || { echo 'Hyprland install.sh failed' >&2; exit 1; }
        else
            echo 'Hyprland install.sh not found' >&2
            exit 1
        fi
        " || error "Failed to execute install.sh Hyprland script in chroot"

        success "WavesOS Hyprland customizations installed successfully"
}

# Install WavesSDDM
 install_SDDM_theme() {
    log "Installing WavesOS SDDM..."

    # Verify /mnt is mounted
    if ! mountpoint -q /mnt; then
        error "Root partition /mnt is not mounted"
    fi

    show_progress 2 5 "Copying WavesSDDM Theme..."
    # Copy SDDM configs to chroot
    if [ -d /root/WavesSDDM ]; then
        cp -r /root/WavesSDDM /mnt/ || error "Failed to copy WavesSDDM to /mnt/"
    else
        error "WavesSDDM directory not found at /mnt"
    fi
  
       show_progress 4 5 "Setting up configurations..."
    # Set permissions and run install.sh in chroot
    arch-chroot /mnt bash -c "
        [ -f WavesSDDM/install.sh ] 
        chmod +x WavesSDDM/install.sh 
        WavesSDDM//install.sh || echo 'WavesSDDM  install.sh not found or failed' >&2
        " || error "Failed to execute install.sh script in chroot"
        success "WavesOS SDDM Theme installed successfully"
}
install_gnome_extensions() {
    log "Installing GNOME Shell extensions for $USERNAME..."

    # Verify /mnt is mounted
    if ! mountpoint -q /mnt; then
        error "Root partition /mnt is not mounted"
    fi

    # Ensure gnome-shell-extensions directory exists in live environment
    if [ ! -d /root/gnome-shell-extensions ]; then
        error "gnome-shell-extensions directory not found at /root/gnome-shell-extensions"
    fi

    # Copy extension ZIP files to chroot
    mkdir -p /mnt/gnome-shell-extensions || error "Failed to create /mnt/gnome-shell-extensions"
    cp /root/gnome-shell-extensions/{blur-my-shell.zip,burn-my-windows@schneegans.github.com.zip,desktop-cube@schneegans.github.com.zip} /mnt/gnome-shell-extensions/ || error "Failed to copy GNOME extension ZIP files to /mnt/gnome-shell-extensions"

    show_progress 1 4 "Installing Blur My Shell..."
    arch-chroot /mnt su - "$USERNAME" -c "
        if [ -f /gnome-shell-extensions/blur-my-shell.zip ]; then
            gnome-extensions install --force /gnome-shell-extensions/blur-my-shell.zip || { echo 'Failed to install Blur My Shell' >&2; exit 1; }
        else
            echo 'blur-my-shell.zip not found' >&2
            exit 1
        fi
    " || error "Failed to install Blur My Shell"

    show_progress 2 4 "Installing Burn My Windows..."
    arch-chroot /mnt su - "$USERNAME" -c "
        if [ -f /gnome-shell-extensions/burn-my-windows@schneegans.github.com.zip ]; then
            gnome-extensions install --force /gnome-shell-extensions/burn-my-windows@schneegans.github.com.zip || { echo 'Failed to install Burn My Windows' >&2; exit 1; }
        else
            echo 'burn-my-windows@schneegans.github.com.zip not found' >&2
            exit 1
        fi
    " || error "Failed to install Burn My Windows"

    show_progress 3 4 "Installing Desktop Cube..."
    arch-chroot /mnt su - "$USERNAME" -c "
        if [ -f /gnome-shell-extensions/desktop-cube@schneegans.github.com.zip ]; then
            gnome-extensions install --force /gnome-shell-extensions/desktop-cube@schneegans.github.com.zip || { echo 'Failed to install Desktop Cube' >&2; exit 1; }
        else
            echo 'desktop-cube@schneegans.github.com.zip not found' >&2
            exit 1
        fi
    " || error "Failed to install Desktop Cube"

    show_progress 4 4 "Enabling GNOME Shell extensions..."
    arch-chroot /mnt su - "$USERNAME" -c "
        dbus-launch gsettings set org.gnome.shell enabled-extensions \"['blur-my-shell@aunetx', 'burn-my-windows@schneegans.github.com', 'desktop-cube@schneegans.github.com']\" || { echo 'Failed to enable extensions via gsettings' >&2; exit 1; }
        if gsettings get org.gnome.shell enabled-extensions | grep -q 'blur-my-shell@aunetx'; then
            echo 'Extensions successfully enabled in gsettings'
        else
            echo 'ERROR: Failed to verify enabled extensions in gsettings' >&2
            exit 1
        fi
    " || error "Failed to enable GNOME Shell extensions"

    # Cleanup copied extension files
    rm -rf /mnt/gnome-shell-extensions 2>/dev/null || true

    success "GNOME Shell extensions installed and enabled successfully for $USERNAME"
}

setup_kando_autostart() {
    log "Setting up kando-bin autostart for $USERNAME..."

    # Verify /mnt is mounted
    if ! mountpoint -q /mnt; then
        error "Root partition /mnt is not mounted"
    fi

    show_progress 1 1 "Configuring kando-bin autostart..."
    arch-chroot /mnt su - "$USERNAME" -c "
        mkdir -p ~/.config/autostart || { echo 'Failed to create autostart directory' >&2; exit 1; }
        cat > ~/.config/autostart/kando-bin.desktop << 'EOF'
[Desktop Entry]
Type=Application
Name=Kando
Exec=kando
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
EOF
        if [ -f ~/.config/autostart/kando-bin.desktop ]; then
            echo 'kando-bin.desktop successfully created'
        else
            echo 'ERROR: Failed to create kando-bin.desktop' >&2
            exit 1
        fi
    " || error "Failed to configure kando-bin autostart"

    success "kando-bin autostart configured successfully for $USERNAME"
}

set_burn_tvglitch_chroot() {
    log "Setting Burn My Windows TV-Glitch effect for $USERNAME..."

    # Verify /mnt is mounted
    if ! mountpoint -q /mnt; then
        error "Root partition /mnt is not mounted"
    fi

    show_progress 1 1 "Configuring TV-Glitch effect..."
    arch-chroot /mnt su - "$USERNAME" -c "
        mkdir -p /home/$USERNAME/.config/burn-my-windows/profiles || { echo 'Failed to create burn-my-windows profiles directory' >&2; exit 1; }
        
        profile_dir=\"/home/$USERNAME/.config/burn-my-windows/profiles\"
        profile_file=\"\$profile_dir/\$(date +%s).conf.json\"
        
        # Create TV-Glitch profile
        cat > \"\$profile_file\" << 'EOF'
[burn-my-windows-profile]
fire-enable-effect=false
tv-glitch-enable-effect=true
EOF
        
        # Set proper ownership
        chown -R $USERNAME:$USERNAME /home/$USERNAME/.config/burn-my-windows/
        
        if [ -f \"\$profile_file\" ]; then
            echo 'TV-Glitch profile created successfully'
        else
            echo 'ERROR: Failed to create TV-Glitch profile' >&2
            exit 1
        fi
        
        # Create comprehensive Burn My Windows configuration
        mkdir -p /home/$USERNAME/.config/burn-my-windows
        
        # Create preferences file with TV-Glitch settings
        cat > /home/$USERNAME/.config/burn-my-windows/preferences.json << 'PREFS_EOF'
{
  \"open-window-effect\": \"tv-glitch\",
  \"close-window-effect\": \"tv-glitch\",
  \"tv-glitch-open-enabled\": true,
  \"tv-glitch-close-enabled\": true,
  \"tv-glitch-open-animation-time\": 400,
  \"tv-glitch-close-animation-time\": 400
}
PREFS_EOF
        
        # Create autostart script that will configure settings after login
        mkdir -p /home/$USERNAME/.config/autostart
        cat > /home/$USERNAME/.config/autostart/burn-my-windows-setup.desktop << 'AUTOSTART_EOF'
[Desktop Entry]
Type=Application
Name=Burn My Windows TV-Glitch Setup
Exec=bash -c \"sleep 5 && /home/$USERNAME/.config/burn-my-windows-setup.sh\"
Hidden=false
NoDisplay=true
X-GNOME-Autostart-enabled=true
StartupNotify=false
AUTOSTART_EOF
        
        # Create the comprehensive setup script
        cat > /home/$USERNAME/.config/burn-my-windows-setup.sh << 'BMWS_EOF'
#!/bin/bash
# WavesOS TV-Glitch Effect Setup Script

log() { echo \"[$(date)] \$1\" >> /home/$USERNAME/burn-my-windows-setup.log; }
log \"Starting TV-Glitch setup...\"

# Wait for GNOME Shell to be fully loaded
while ! pgrep -x \"gnome-shell\" > /dev/null; do
    log \"Waiting for GNOME Shell...\"
    sleep 2
done

# Wait additional time for extensions to be loaded
sleep 3

# Check if Burn My Windows extension is enabled
if ! gnome-extensions list --enabled | grep -q \"burn-my-windows\"; then
    log \"Enabling Burn My Windows extension...\"
    gnome-extensions enable burn-my-windows@schneegans.github.com
    sleep 2
fi

# Apply TV-Glitch settings with retry logic
for attempt in {1..5}; do
    log \"Attempt \$attempt to set TV-Glitch effects...\"
    
    # Try to set the effects
    if gsettings set org.gnome.shell.extensions.burn-my-windows open-window-effect 'tv-glitch' 2>/dev/null &&
       gsettings set org.gnome.shell.extensions.burn-my-windows close-window-effect 'tv-glitch' 2>/dev/null; then
        log \"Successfully set TV-Glitch effects\"
        
        # Additional specific settings for TV-Glitch
        gsettings set org.gnome.shell.extensions.burn-my-windows tv-glitch-open-enabled true 2>/dev/null || true
        gsettings set org.gnome.shell.extensions.burn-my-windows tv-glitch-close-enabled true 2>/dev/null || true
        
        # Verify the settings were applied
        open_effect=\$(gsettings get org.gnome.shell.extensions.burn-my-windows open-window-effect 2>/dev/null)
        close_effect=\$(gsettings get org.gnome.shell.extensions.burn-my-windows close-window-effect 2>/dev/null)
        
        if [[ \"\$open_effect\" == \"'tv-glitch'\" && \"\$close_effect\" == \"'tv-glitch'\" ]]; then
            log \"TV-Glitch effect verified and activated!\"
            notify-send \"WavesOS\" \"TV-Glitch effect activated successfully!\" --icon=dialog-information
            
            # Clean up
            rm -f /home/$USERNAME/.config/autostart/burn-my-windows-setup.desktop
            rm -f /home/$USERNAME/.config/burn-my-windows-setup.sh
            exit 0
        fi
    fi
    
    log \"Attempt \$attempt failed, waiting before retry...\"
    sleep 3
done

log \"Failed to set TV-Glitch effect after 5 attempts\"
notify-send \"WavesOS\" \"Failed to activate TV-Glitch effect. Run setup-tv-glitch.sh manually.\" --icon=dialog-warning

# Keep the manual script for user to try later
log \"Setup incomplete. Manual script available at /home/$USERNAME/setup-tv-glitch.sh\"
BMWS_EOF
        
        chmod +x /home/$USERNAME/.config/burn-my-windows-setup.sh
        
        # Also create a manual setup script in case autostart doesn't work
        cat > /home/$USERNAME/setup-tv-glitch.sh << 'SETUP_EOF'
#!/bin/bash
echo \"Setting up TV-Glitch effect for Burn My Windows...\"
gsettings set org.gnome.shell.extensions.burn-my-windows open-window-effect 'tv-glitch'
gsettings set org.gnome.shell.extensions.burn-my-windows close-window-effect 'tv-glitch'
gsettings set org.gnome.shell.extensions.burn-my-windows tv-glitch-open-enabled true
gsettings set org.gnome.shell.extensions.burn-my-windows tv-glitch-close-enabled true
echo \"TV-Glitch effect configured! You may need to restart GNOME Shell (Alt+F2, type 'r', press Enter)\"
rm \$0
SETUP_EOF
        
        chmod +x /home/$USERNAME/setup-tv-glitch.sh
        
        # Set proper ownership for all created files
        chown -R $USERNAME:$USERNAME /home/$USERNAME/.config/burn-my-windows/
        chown $USERNAME:$USERNAME /home/$USERNAME/.config/autostart/burn-my-windows-setup.desktop
        chown $USERNAME:$USERNAME /home/$USERNAME/setup-tv-glitch.sh
        
        echo 'Created TV-Glitch configuration files and setup scripts'
        
    " || error "Failed to configure TV-Glitch effect"

    success "TV-Glitch effect configured successfully for $USERNAME"
}

# Add the new function here
configure_os_release() {
    log "Configuring /etc/os-release for WavesOS..."

    # Verify /mnt is mounted
    if ! mountpoint -q /mnt; then
        error "Root partition /mnt is not mounted"
    fi

    # Check if /etc/os-release exists in live environment
    if [ ! -f /etc/os-release ]; then
        error "/etc/os-release not found in live environment"
    fi

    show_progress 1 1 "Copying /etc/os-release to installed system..."
    cp /etc/os-release /mnt/etc/os-release || error "Failed to copy /etc/os-release to /mnt/etc/os-release"
    chmod 644 /mnt/etc/os-release || error "Failed to set permissions on /mnt/etc/os-release"

    # Verify the copied file
    if [ -f /mnt/etc/os-release ] && grep -q '^NAME="WavesOS"$' /mnt/etc/os-release; then
        echo "/etc/os-release successfully copied and configured"
    else
        error "Failed to verify /etc/os-release content"
    fi

    success "Successfully configured /etc/os-release for WavesOS"
}

set_default_WavesOS_theme() {
    log "Setting WavesOS theme for $USERNAME..."

    # Verify /mnt is mounted
    if ! mountpoint -q /mnt; then
        error "Root partition /mnt is not mounted"
    fi

    # Check if kora-pgrey icon theme is installed
    if ! [ -d /mnt/usr/share/icons/kora-pgrey ]; then
        error "kora-pgrey icon theme not found in /mnt/usr/share/icons"
    fi

    show_progress 1 1 "Configuring WavesOS theme..."
    arch-chroot /mnt su - "$USERNAME" -c "
       dbus-launch gsettings set org.gnome.desktop.interface icon-theme 'kora-pgrey'
       dbus-launch gsettings set org.gnome.desktop.background picture-uri '/home/$USERNAME/.config/hypr/Wallpaper/linux.jpg'
       dbus-launch gsettings set org.gnome.desktop.background picture-uri-dark '/home/$USERNAME/.config/hypr/Wallpaper/linux.jpg'  || { echo 'Failed to set icon theme via gsettings' >&2; exit 1; }
        if [ \"\$(gsettings get org.gnome.desktop.interface icon-theme)\" = \"'kora-pgrey'\" ]; then
            echo 'Default WavesOS customizations are successfully configured'
        else
            echo 'ERROR: Failed to verify kora-pgrey icon theme' >&2
            exit 1
        fi
    " || error "Failed to configure kora-pgrey icon theme"

    success "Successfully set kora-pgrey as default icon theme for $USERNAME"
}

# Final system verification
verify_installation() {
    log "Performing final system verification..."
    
    local checks_passed=0
    local total_checks=6
    
    # Check 1: Root partition mounted
    if mountpoint -q /mnt; then
        success "✓ Root partition properly mounted"
        ((checks_passed++))
    else
        error "✗ Root partition not mounted"
    fi
    
    # Check 2: Boot partition (UEFI only)
    if [ "$BOOT_MODE" = "uefi" ]; then
        if mountpoint -q /mnt/boot; then
            success "✓ EFI boot partition properly mounted"
            ((checks_passed++))
        else
            error "✗ EFI boot partition not mounted"
        fi
    else
        success "✓ BIOS boot configuration verified"
        ((checks_passed++))
    fi
    
    # Check 3: Bootloader files
    if [ "$BOOT_MODE" = "uefi" ]; then
        if [ -f /mnt/boot/EFI/WavesOS/grubx64.efi ]; then
            success "✓ UEFI bootloader files present"
            ((checks_passed++))
        else
            warning "✗ UEFI bootloader files missing"
        fi
    else
        if [ -f /mnt/boot/grub/grub.cfg ]; then
            success "✓ BIOS bootloader configuration present"
            ((checks_passed++))
        else
            warning "✗ BIOS bootloader configuration missing"
        fi
    fi
    
    # Check 4: User account
    if arch-chroot /mnt id "$USERNAME" &>/dev/null; then
        success "✓ User account '$USERNAME' created"
        ((checks_passed++))
    else
        error "✗ User account '$USERNAME' not found"
    fi
    
    # Check 5: Essential services
    if arch-chroot /mnt systemctl is-enabled NetworkManager &>/dev/null; then
        success "✓ NetworkManager service enabled"
        ((checks_passed++))
    else
        warning "✗ NetworkManager service not enabled"
    fi
    
    # Check 6: Hyprland installation
    if arch-chroot /mnt which hyprland &>/dev/null; then
        success "✓ Hyprland desktop environment installed"
        ((checks_passed++))
    else
        warning "✗ Hyprland not found"
    fi
    
    echo
    info "Installation verification: $checks_passed/$total_checks checks passed"
    
    if [ $checks_passed -ge 4 ]; then
        success "System verification passed! Installation should be bootable."
        return 0
    else
        error "System verification failed! Installation may not boot properly."
        return 1
    fi
}

# Cleanup and unmount
cleanup_installation() {
    log "Cleaning up and unmounting filesystems..."
    
    # Disable swap if enabled
    if [ "$SWAP_SIZE" -gt 0 ]; then
        swapoff "$SWAP_PART" 2>/dev/null || true
    fi
    
    # Unmount in reverse order
    umount /mnt/home/storage 2>/dev/null || true
    umount /mnt/boot 2>/dev/null || true
    umount /mnt 2>/dev/null || true
    
    success "Cleanup completed"
}

# Installation summary
show_installation_summary() {
    echo
    echo -e "${CYAN}╔════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║                   INSTALLATION COMPLETE                   ║${NC}"
    echo -e "${CYAN}╚════════════════════════════════════════════════════════════╝${NC}"
    echo
    success "WavesOS has been installed successfully!"
    echo
    info "Installation Summary:"
    info "• System disk: $SYS_DISK"
    info "• Boot mode: $BOOT_MODE"
    info "• Hostname: $HOSTNAME"
    info "• Username: $USERNAME"
    info "• Desktop: Hyprland with WavesOS configs"
    [ -n "$STORE_DISK" ] && info "• Storage disk: $STORE_DISK"
    echo
    info "Next steps:"
    info "1. Remove the installation media"
    info "2. Reboot the system"
    info "3. Log in with your user credentials"
    info "4. Enjoy WavesOS with Hyprland!"
    echo
    warning "IMPORTANT: Please remove the USB installation media before rebooting!"
    echo
    read -p "Press Enter to reboot now, or Ctrl+C to exit to shell: "
    reboot
}

# Main installation function
main() {
    show_banner
    
    # Pre-installation checks
    check_root
    check_live_env
    check_tools
    check_network
    update_clock
    
    # Disk preparation
    detect_disks
    show_hardware
    select_disks
    detect_boot_mode
    configure_partitions
    confirm_partitioning
    
    # Disk operations
    create_partitions
    format_partitions
    mount_partitions
    
    # System installation
    update_mirrorlist
    install_base_system
    install_bootloader_packages
    install_graphics_drivers
    install_desktop_environment
    install_custom_packages
    copy_custom_repo
    generate_fstab
    
    # System configuration
    configure_system
    apply_chroot_config
    install_bootloader
    install_wavesos_customizations
    install_SDDM_theme
    install_gnome_extensions 
    setup_kando_autostart
    set_burn_tvglitch_chroot
    configure_os_release
    set_default_WavesOS_theme

    # Final steps
    verify_installation
    cleanup_installation
    show_installation_summary
}

# Error handling
trap 'error "Installation interrupted by user or system error"' INT TERM

# Run main installation
main "$@"




